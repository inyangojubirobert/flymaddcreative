<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flymadd Creative</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gray-100 flex items-center justify-center min-h-screen overflow-hidden relative">
    <!-- Preloader / Animation -->
    <div id="preloader"
        class="absolute inset-0 bg-white flex items-center justify-center z-50 transition-opacity duration-500">
        <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-blue-500"></div>
    </div>

    <!-- Object-Oriented Canvas Animation (background) -->
    <canvas id="scene" class="absolute inset-0 w-full h-full z-0"></canvas>

    <!-- Main Content -->
    <div id="mainContent" class="opacity-0 transition-opacity duration-1000 text-center px-4 relative z-10">
        <h1 class="text-5xl font-bold mb-4 text-gray-800">Welcome to Flymadd Creative</h1>
        <p class="text-xl text-gray-600">Our website is coming soon ðŸš€</p>
        <button class="mt-8 px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">Contact
            Us</button>
    </div>

    <script>
        // Object-Oriented Canvas Animation
        class Particle {
            constructor(x, y, vx, vy, r, color) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.r = r; this.color = color;
            }
            update(width, height) {
                this.x += this.vx; this.y += this.vy;
                if (this.x - this.r < 0 || this.x + this.r > width) this.vx *= -1;
                if (this.y - this.r < 0 || this.y + this.r > height) this.vy *= -1;
            }
            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        class Scene {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.particles = [];
                this.animationId = null;
                this.handleResize = this.resize.bind(this);
                this.pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
                this.resize();
                window.addEventListener('resize', this.handleResize);
                this.initParticles();
            }
            resize() {
                const { clientWidth: w, clientHeight: h } = this.canvas;
                this.canvas.width = Math.floor(w * this.pixelRatio);
                this.canvas.height = Math.floor(h * this.pixelRatio);
                this.ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
            }
            initParticles() {
                this.particles = [];
                const w = this.canvas.clientWidth; const h = this.canvas.clientHeight;
                const count = Math.max(20, Math.floor((w * h) / 25000));
                const palette = ['#3b82f6', '#06b6d4', '#10b981', '#f59e0b'];
                for (let i = 0; i < count; i++) {
                    const r = 3 + Math.random() * 6;
                    const x = r + Math.random() * (w - 2 * r);
                    const y = r + Math.random() * (h - 2 * r);
                    const speed = 0.4 + Math.random() * 1.2;
                    const angle = Math.random() * Math.PI * 2;
                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;
                    const color = palette[i % palette.length];
                    this.particles.push(new Particle(x, y, vx, vy, r, color));
                }
            }
            step() {
                const w = this.canvas.clientWidth; const h = this.canvas.clientHeight;
                this.ctx.clearRect(0, 0, w, h);
                // soft background gradient
                const grad = this.ctx.createLinearGradient(0, 0, w, h);
                grad.addColorStop(0, 'rgba(59,130,246,0.06)');
                grad.addColorStop(1, 'rgba(16,185,129,0.06)');
                this.ctx.fillStyle = grad;
                this.ctx.fillRect(0, 0, w, h);

                // draw connections
                for (let i = 0; i < this.particles.length; i++) {
                    const a = this.particles[i];
                    a.update(w, h);
                    a.draw(this.ctx);
                    for (let j = i + 1; j < this.particles.length; j++) {
                        const b = this.particles[j];
                        const dx = a.x - b.x, dy = a.y - b.y;
                        const dist2 = dx * dx + dy * dy;
                        if (dist2 < 140 * 140) {
                            const alpha = Math.max(0, 1 - Math.sqrt(dist2) / 140) * 0.6;
                            this.ctx.strokeStyle = `rgba(59,130,246,${alpha})`;
                            this.ctx.lineWidth = 1;
                            this.ctx.beginPath();
                            this.ctx.moveTo(a.x, a.y);
                            this.ctx.lineTo(b.x, b.y);
                            this.ctx.stroke();
                        }
                    }
                }
            }
            start() {
                const loop = () => {
                    this.step();
                    this.animationId = requestAnimationFrame(loop);
                };
                loop();
            }
            stop() { if (this.animationId) cancelAnimationFrame(this.animationId); }
            destroy() {
                this.stop();
                window.removeEventListener('resize', this.handleResize);
            }
        }

        // Wait until the page fully loads, then fade out preloader and start scene
        window.addEventListener('load', () => {
            const preloader = document.getElementById('preloader');
            const mainContent = document.getElementById('mainContent');
            const canvas = document.getElementById('scene');

            preloader.style.opacity = '0';
            setTimeout(() => {
                preloader.style.display = 'none';
                mainContent.classList.add('opacity-100');

                const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                if (!prefersReduced) {
                    // ensure canvas sizes match current viewport
                    canvas.width = canvas.clientWidth;
                    canvas.height = canvas.clientHeight;
                    const scene = new Scene(canvas);
                    scene.start();
                }
            }, 500); // match the transition
        });
    </script>

    <style>
        /* Ensure canvas fills background without causing scroll */
        #scene {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* Respect reduced motion preferences */
        @media (prefers-reduced-motion: reduce) {
            #scene {
                display: none;
            }
        }
    </style>

</body>

</html>