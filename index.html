<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flymadd Creative</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-gray-100 flex items-center justify-center min-h-screen overflow-hidden relative">
    <!-- Preloader / Animation -->
    <div id="preloader"
        class="absolute inset-0 bg-white flex items-center justify-center z-50 transition-opacity duration-500">
        <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-blue-500"></div>
    </div>

    <!-- Object-Oriented Canvas Animation (background) -->
    <canvas id="scene" class="absolute inset-0 w-full h-full z-0"></canvas>

    <!-- Main Content -->
    <div id="mainContent" class="opacity-0 transition-opacity duration-1000 text-center px-4 relative z-10">
        <h1 class="text-5xl font-bold mb-4 text-gray-800">Welcome to Flymadd Creative</h1>
        <p class="text-xl text-gray-600">Our website is coming soon ðŸš€</p>
        <button class="mt-8 px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">Contact
            Us</button>
    </div>

    <script>
        // High-tech circuit animation (OOP)
        class Track {
            constructor(points, color = '#22d3ee') {
                this.points = points; // [{x,y}, ...]
                this.color = color;
            }
            length() {
                let L = 0;
                for (let i = 0; i < this.points.length - 1; i++) {
                    const a = this.points[i], b = this.points[i + 1];
                    L += Math.hypot(b.x - a.x, b.y - a.y);
                }
                return L;
            }
            draw(ctx) {
                ctx.save();
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) ctx.lineTo(this.points[i].x, this.points[i].y);
                ctx.stroke();
                ctx.restore();
            }
        }

        class Pulse {
            constructor(track, speed, size = 3, color = '#38bdf8') {
                this.track = track; this.speed = speed; this.size = size; this.color = color;
                this.seg = 0; this.t = 0; // position along current segment
            }
            update(dt) {
                // advance along polyline
                while (dt > 0) {
                    const a = this.track.points[this.seg];
                    const b = this.track.points[this.seg + 1];
                    const segLen = Math.hypot(b.x - a.x, b.y - a.y);
                    const remain = (1 - this.t) * segLen;
                    const step = Math.min(remain, this.speed * dt);
                    this.t += step / segLen;
                    dt -= step / this.speed;
                    if (this.t >= 1) { this.t = 0; this.seg = (this.seg + 1) % (this.track.points.length - 1); }
                }
            }
            position() {
                const a = this.track.points[this.seg];
                const b = this.track.points[this.seg + 1];
                return { x: a.x + (b.x - a.x) * this.t, y: a.y + (b.y - a.y) * this.t };
            }
            draw(ctx) {
                const p = this.position();
                ctx.save();
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 16;
                ctx.beginPath();
                ctx.arc(p.x, p.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        class Scene {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.pixelRatio = Math.min(window.devicePixelRatio || 1, 2);
                this.tracks = [];
                this.pulses = [];
                this.animationId = null;
                this.lastTime = performance.now();
                this.handleResize = this.resize.bind(this);
                this.resize();
                window.addEventListener('resize', this.handleResize);
                this.init();
            }
            resize() {
                const { clientWidth: w, clientHeight: h } = this.canvas;
                this.canvas.width = Math.floor(w * this.pixelRatio);
                this.canvas.height = Math.floor(h * this.pixelRatio);
                this.ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
            }
            init() {
                const w = this.canvas.clientWidth, h = this.canvas.clientHeight;
                const grid = 48; // grid size for right-angle paths
                const margin = grid * 1.5;
                const palette = ['#22d3ee', '#60a5fa', '#34d399', '#a78bfa'];

                // background grid lines for tech look
                this.bgGrid = { grid, color: 'rgba(148,163,184,0.10)' };

                const trackCount = Math.max(12, Math.floor((w + h) / 120));
                this.tracks = [];
                for (let i = 0; i < trackCount; i++) {
                    const color = palette[i % palette.length];
                    const pts = [];
                    let x = margin + Math.floor(Math.random() * ((w - margin * 2) / grid)) * grid;
                    let y = margin + Math.floor(Math.random() * ((h - margin * 2) / grid)) * grid;
                    pts.push({ x, y });
                    const steps = 3 + Math.floor(Math.random() * 5);
                    let dir = Math.random() < 0.5 ? 'h' : 'v';
                    for (let s = 0; s < steps; s++) {
                        if (dir === 'h') {
                            const maxStep = Math.floor((w - margin - x) / grid);
                            const minStep = -Math.floor((x - margin) / grid);
                            const step = Math.max(-3, Math.min(3, (Math.random() * 6 | 0) - 3));
                            const move = Math.max(1, Math.min(dir === 'h' ? maxStep : 0, Math.abs(step)));
                            x += Math.sign(step || 1) * move * grid;
                        } else {
                            const maxStep = Math.floor((h - margin - y) / grid);
                            const minStep = -Math.floor((y - margin) / grid);
                            const step = Math.max(-3, Math.min(3, (Math.random() * 6 | 0) - 3));
                            const move = Math.max(1, Math.min(dir === 'v' ? maxStep : 0, Math.abs(step)));
                            y += Math.sign(step || 1) * move * grid;
                        }
                        pts.push({ x, y });
                        dir = dir === 'h' ? 'v' : 'h';
                    }
                    this.tracks.push(new Track(pts, color));
                }

                // pulses on tracks
                this.pulses = [];
                for (const t of this.tracks) {
                    const n = 1 + (Math.random() < 0.5 ? 1 : 0);
                    for (let k = 0; k < n; k++) {
                        const speed = 80 + Math.random() * 140; // px/sec
                        const p = new Pulse(t, speed, 2.5 + Math.random() * 1.5, t.color);
                        p.seg = Math.floor(Math.random() * (t.points.length - 1));
                        p.t = Math.random();
                        this.pulses.push(p);
                    }
                }
            }
            drawGrid() {
                const { grid, color } = this.bgGrid;
                const w = this.canvas.clientWidth, h = this.canvas.clientHeight;
                const ctx = this.ctx;
                ctx.save();
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                for (let x = 0; x <= w; x += grid) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
                for (let y = 0; y <= h; y += grid) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }
                ctx.restore();
            }
            step(dt) {
                const w = this.canvas.clientWidth; const h = this.canvas.clientHeight;
                const ctx = this.ctx;
                ctx.clearRect(0, 0, w, h);

                // subtle dark gradient background overlay
                const grad = ctx.createLinearGradient(0, 0, w, h);
                grad.addColorStop(0, 'rgba(2,6,23,0.25)');
                grad.addColorStop(1, 'rgba(15,23,42,0.25)');
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, w, h);

                this.drawGrid();

                // draw tracks
                for (const t of this.tracks) t.draw(ctx);

                // update and draw pulses
                for (const p of this.pulses) { p.update(dt); p.draw(ctx); }

                // occasional scanline sweep
                const time = performance.now() * 0.001;
                const sweepY = (Math.sin(time * 0.5) * 0.5 + 0.5) * h;
                const grad2 = ctx.createLinearGradient(0, sweepY - 40, 0, sweepY + 40);
                grad2.addColorStop(0, 'rgba(56,189,248,0)');
                grad2.addColorStop(0.5, 'rgba(56,189,248,0.12)');
                grad2.addColorStop(1, 'rgba(56,189,248,0)');
                ctx.fillStyle = grad2;
                ctx.fillRect(0, sweepY - 40, w, 80);
            }
            start() {
                const loop = (now) => {
                    const dt = Math.min(0.05, (now - this.lastTime) / 1000);
                    this.lastTime = now;
                    this.step(dt);
                    this.animationId = requestAnimationFrame(loop);
                };
                this.lastTime = performance.now();
                this.animationId = requestAnimationFrame(loop);
            }
            stop() { if (this.animationId) cancelAnimationFrame(this.animationId); }
            destroy() {
                this.stop();
                window.removeEventListener('resize', this.handleResize);
            }
        }

        // Wait until the page fully loads, then fade out preloader and start scene
        window.addEventListener('load', () => {
            const preloader = document.getElementById('preloader');
            const mainContent = document.getElementById('mainContent');
            const canvas = document.getElementById('scene');

            preloader.style.opacity = '0';
            setTimeout(() => {
                preloader.style.display = 'none';
                mainContent.classList.add('opacity-100');

                const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
                if (!prefersReduced) {
                    canvas.width = canvas.clientWidth;
                    canvas.height = canvas.clientHeight;
                    const scene = new Scene(canvas);
                    scene.start();
                }
            }, 500);
        });
    </script>

    <style>
        /* Ensure canvas fills background without causing scroll */
        #scene {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* Respect reduced motion preferences */
        @media (prefers-reduced-motion: reduce) {
            #scene {
                display: none;
            }
        }
    </style>

</body>

</html>