// ======================================================<!-- Scripts section - ensure correct loading order -->

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































console.log('‚úÖ Crypto Payments module loaded');document.dispatchEvent(new CustomEvent('cryptoPaymentsReady'));// ‚úÖ Dispatch custom event to notify listeners that module is loadedwindow.CryptoPaymentsReady = true;// ‚úÖ Set ready flag for external scripts to check};    ERROR_CODES    CONFIG,    showNetworkSelectionModal,    showTronManualModal,    showBSCManualModal,    initiate: initiateCryptoPayment,window.CryptoPayments = {window.initiateCryptoPayment = initiateCryptoPayment;// ======================================================// üåç  GLOBAL EXPORTS// ======================================================}    }        return { success: false, error: error.message };                });            participantId             code: error.code,            error: error.message,         trackEvent('payment_error', {                 }            alert(error.message || 'Payment failed. Please try again.');        } else {            errorStatus(modal, error);        if (modal) {                console.error('[CryptoPayment] Error:', error);    } catch (error) {                }            return { success: true, ...result };            successStatus(modal, result.txHash, result.explorerUrl);                        await finalizePayment(result.txHash, selectedNetwork);            updateStatus(modal, 'Finalizing...');                        const result = await executeTronTransfer(recipient, amount);            updateStatus(modal, 'Confirm in wallet...');        } else if (selectedNetwork === 'TRON') {                        return { success: true, ...result };            successStatus(modal, result.txHash, result.explorerUrl);                        await finalizePayment(result.txHash, selectedNetwork);            updateStatus(modal, 'Finalizing...');                        const result = await executeBSCTransferUnified(window.ethereum, recipient, amount);            updateStatus(modal, 'Confirm in wallet...');                        await ensureBSCNetworkDesktop(window.ethereum);                        }                throw new PaymentError('Failed to connect wallet', ERROR_CODES.WALLET_ERROR);            if (!connected) {            const connected = await requestWalletConnection();                        updateStatus(modal, 'Connecting wallet...');        if (selectedNetwork === 'BSC') {                modal = showPaymentStatusModal(selectedNetwork, amount);        // Wallet is available - proceed with transaction                }            return { success: false, cancelled: true };                        }                return { success: true, ...result };                successStatus(modal, result.txHash, result.explorerUrl);                                await finalizePayment(result.txHash, selectedNetwork);                updateStatus(modal, 'Finalizing...');                                const result = await executeBSCTransferUnified(provider, recipient, amount);                                updateStatus(modal, 'Sending transaction...');                const provider = await connectWalletMobile();                                updateStatus(modal, 'Connecting wallet...');                modal = showPaymentStatusModal(selectedNetwork, amount);                // Use WalletConnect            if (choice === 'walletconnect' && selectedNetwork === 'BSC') {                        }                }                    return await showTronManualModal(recipient, amount);                } else {                    return await showBSCManualModal(recipient, amount);                if (selectedNetwork === 'BSC') {                // Show manual payment modal            if (choice === 'qr') {                        }                return initiateCryptoPayment(participantId, voteCount, amount);            if (choice === 'back') {                        const choice = await showDesktopWalletModal();            // No wallet detected - show options        if (!hasWallet) {                    : (window.tronWeb && window.tronWeb.ready);            ? await waitForWalletProvider(2000)        const hasWallet = selectedNetwork === 'BSC'         // Check for wallet availability                    : CONFIG.TRON.WALLET_ADDRESS;            ? CONFIG.BSC.WALLET_ADDRESS         const recipient = selectedNetwork === 'BSC'         // Get wallet address based on network                }            return { success: false, cancelled: true };        if (!selectedNetwork) {        const selectedNetwork = await showNetworkSelectionModal(preferredNetwork);        // Show network selection                const preferredNetwork = await detectPreferredNetwork();        // Detect preferred network                checkRateLimit(participantId);        validateInputs(participantId, voteCount);        // Validate inputs    try {        let modal = null;async function initiateCryptoPayment(participantId, voteCount, amount) {// ======================================================// üöÄ  MAIN ENTRY POINT// ======================================================}    if (closeBtn) closeBtn.classList.remove('hidden');    const closeBtn = modal.querySelector('#closeModal');    if (spinner) spinner.remove();    const spinner = modal.querySelector('.loading-spinner');    updateStatus(modal, `‚ùå ${message}`);    }        message = 'Wallet connection error - please refresh and try again';    if (error.message && error.message.includes('ethers.BrowserProvider')) {    let message = error.message || 'Payment failed';function errorStatus(modal, error) {}    setTimeout(() => modal.remove(), 5000);        }        txLink.classList.remove('hidden');        if (link) link.href = explorerUrl;        const link = txLink.querySelector('a');    if (txLink) {    const txLink = modal.querySelector('#txLink');        if (spinner) spinner.remove();    const spinner = modal.querySelector('.loading-spinner');    updateStatus(modal, '‚úÖ Payment confirmed');function successStatus(modal, txHash, explorerUrl) {}    if (element) element.textContent = text;    const element = modal.querySelector('#statusText');function updateStatus(modal, text) {}    });        modal.querySelector('#closeTron').onclick = () => { modal.remove(); resolve({ success: false, cancelled: true }); };        };            }                resolve({ success: false, manual: true, pendingConfirmation: true });            } else {                resolve({ success: true, manual: true, txHash, explorerUrl: `${CONFIG.TRON.EXPLORER}${txHash}` });            if (txHash && /^[a-fA-F0-9]{64}$/.test(txHash)) {            modal.remove();                        }                }                    return;                if (!confirm('No transaction hash entered. Are you sure you have already sent the payment?')) {            if (!txHash) {                        const txHash = modal.querySelector('#txHashInput').value.trim();        modal.querySelector('#confirmPayment').onclick = () => {        };                .catch(() => alert('Failed to copy address'));                })                    setTimeout(() => { modal.querySelector('#copyAddress').textContent = 'üìã Copy Address'; }, 2000);                    modal.querySelector('#copyAddress').textContent = '‚úÖ Copied!';                .then(() => {            navigator.clipboard.writeText(recipient)        modal.querySelector('#copyAddress').onclick = () => {        generateQR(recipient, 'tronQR');        `);            </div>                <button id="closeTron" class="w-full bg-gray-200 hover:bg-gray-300 py-2 rounded text-sm">Cancel</button>                </div>                    <button id="confirmPayment" class="w-full bg-green-600 hover:bg-green-700 text-white py-2 rounded text-sm mb-2">‚úÖ I've Paid</button>                    <input type="text" id="txHashInput" placeholder="Paste transaction hash (optional)" class="w-full text-xs p-2 border rounded mb-2" />                    <p class="text-xs text-gray-500 mb-2">Already sent payment?</p>                <div class="border-t pt-3 mt-3">                <button id="copyAddress" class="text-blue-500 text-xs mb-3">üìã Copy Address</button>                <p class="text-xs text-red-500 mb-2">‚ö†Ô∏è Send only USDT on TRON network</p>                <div id="tronQR" class="mx-auto mb-3"></div>                <div class="bg-gray-100 p-2 rounded break-all text-xs mb-3 font-mono">${recipient}</div>                <p class="text-sm mb-2">Send <strong>${amount} USDT</strong> (TRC-20) to:</p>                <h3 class="font-bold mb-3">TRON USDT Payment</h3>            <div class="bg-white p-6 rounded-xl text-center w-80 max-w-[95vw]">        const modal = createModal(`    return new Promise((resolve) => {function showTronManualModal(recipient, amount) {}    });        modal.querySelector('#closeBSC').onclick = () => { modal.remove(); resolve({ success: false, cancelled: true }); };        };            }                resolve({ success: false, manual: true, pendingConfirmation: true });            } else {                resolve({ success: true, manual: true, txHash, explorerUrl: `${CONFIG.BSC.EXPLORER}${txHash}` });            if (txHash && /^0x[a-fA-F0-9]{64}$/.test(txHash)) {            modal.remove();                        }                }                    return;                if (!confirm('No transaction hash entered. Are you sure you have already sent the payment?')) {            if (!txHash) {                        const txHash = modal.querySelector('#txHashInput').value.trim();        modal.querySelector('#confirmPayment').onclick = () => {        };                .catch(() => alert('Failed to copy address'));                })                    setTimeout(() => { modal.querySelector('#copyAddress').textContent = 'üìã Copy Address'; }, 2000);                    modal.querySelector('#copyAddress').textContent = '‚úÖ Copied!';                .then(() => {            navigator.clipboard.writeText(recipient)        modal.querySelector('#copyAddress').onclick = () => {        generateQR(recipient, 'bscQR');        `);            </div>                <button id="closeBSC" class="w-full bg-gray-200 hover:bg-gray-300 py-2 rounded text-sm">Cancel</button>                </div>                    <button id="confirmPayment" class="w-full bg-green-600 hover:bg-green-700 text-white py-2 rounded text-sm mb-2">‚úÖ I've Paid</button>                    <input type="text" id="txHashInput" placeholder="Paste transaction hash (optional)" class="w-full text-xs p-2 border rounded mb-2" />                    <p class="text-xs text-gray-500 mb-2">Already sent payment?</p>                <div class="border-t pt-3 mt-3">                <button id="copyAddress" class="text-blue-500 text-xs mb-3">üìã Copy Address</button>                <p class="text-xs text-red-500 mb-2">‚ö†Ô∏è Send only USDT on BSC network</p>                <div id="bscQR" class="mx-auto mb-3"></div>                <div class="bg-gray-100 p-2 rounded break-all text-xs mb-3 font-mono">${recipient}</div>                <p class="text-sm mb-2">Send <strong>${amount} USDT</strong> (BEP-20) to:</p>                <h3 class="font-bold mb-3">BSC USDT Payment</h3>            <div class="bg-white p-6 rounded-xl text-center w-80 max-w-[95vw]">        const modal = createModal(`    return new Promise((resolve) => {function showBSCManualModal(recipient, amount) {}    });        modal.querySelector('#goBack').onclick = () => { modal.remove(); resolve('back'); };        modal.querySelector('#useQR').onclick = () => { modal.remove(); resolve('qr'); };        modal.querySelector('#useWalletConnect').onclick = () => { modal.remove(); resolve('walletconnect'); };        `);            </div>                <button id="goBack" class="w-full bg-gray-200 hover:bg-gray-300 py-2 rounded mt-2">‚Üê Back</button>                </button>                    <span>üì±</span> Pay via QR Code                <button id="useQR" class="w-full bg-gray-800 hover:bg-gray-900 text-white py-3 rounded mb-2 flex items-center justify-center gap-2">                </button>                    <span>üîó</span> Connect via WalletConnect                <button id="useWalletConnect" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-3 rounded mb-2 flex items-center justify-center gap-2">                <p class="text-sm text-gray-600 mb-4">Choose how you'd like to complete your payment:</p>                <h3 class="font-bold mb-3 text-lg">üì± Connect Your Wallet</h3>            <div class="bg-white p-6 rounded-xl text-center w-80 max-w-[90vw]">        const modal = createModal(`    return new Promise((resolve) => {function showDesktopWalletModal() {}    });        }            }, 100);                if (el) el.classList.add('ring-2', 'ring-blue-500');                const el = modal.querySelector(`#${preferredNetwork.toLowerCase()}`);            setTimeout(() => {        if (preferredNetwork) {        modal.querySelector('#cancel').onclick = () => { modal.remove(); resolve(null); };        modal.querySelector('#tron').onclick = () => { modal.remove(); resolve('TRON'); };        modal.querySelector('#bsc').onclick = () => { modal.remove(); resolve('BSC'); };        `);            </div>                <button id="cancel" class="mt-4 text-gray-500 text-sm">Cancel</button>                </button>                    ${preferredNetwork === 'TRON' ? '<span class="text-xs">(Detected)</span>' : ''}                    <span>üî¥</span> TRON (TRC-20)                <button id="tron" class="w-full bg-red-600 hover:bg-red-700 text-white py-3 rounded flex items-center justify-center gap-2 transition-colors">                </button>                    ${preferredNetwork === 'BSC' ? '<span class="text-xs">(Detected)</span>' : ''}                    <span>üü°</span> BSC (BEP-20)                <button id="bsc" class="w-full bg-yellow-400 hover:bg-yellow-500 py-3 rounded mb-3 flex items-center justify-center gap-2 transition-colors">                <h3 class="font-bold mb-4">Choose Network</h3>            <div class="bg-white p-6 rounded-xl w-80 text-center">        const modal = createModal(`    return new Promise((resolve) => {function showNetworkSelectionModal(preferredNetwork) {}    `);        </div>            <button id="closeModal" class="mt-4 text-gray-500 text-sm">Close</button>            </div>                <a href="#" target="_blank" rel="noopener noreferrer" class="text-blue-500">View on explorer</a>            <div id="txLink" class="mt-4 text-sm hidden">            <div class="loading-spinner mx-auto mt-4"></div>            <div id="statusText" class="min-h-6 mb-4">Initializing‚Ä¶</div>            <div class="text-2xl font-bold mb-4">${amount} USDT</div>            </div>                <span class="text-xs bg-gray-100 px-2 py-1 rounded">${network === 'BSC' ? 'BEP-20' : 'TRC-20'}</span>                <h3 class="font-bold text-lg">${network} Payment</h3>            <div class="flex justify-between items-center mb-3">        <div class="bg-white p-6 rounded-xl text-center w-80 max-w-[90vw]">    return createModal(`function showPaymentStatusModal(network, amount) {}    return modal;    document.body.appendChild(modal);    modal.innerHTML = content;    modal.className = `fixed inset-0 bg-black/80 flex items-center justify-center z-50 ${className}`;    const modal = document.createElement('div');function createModal(content, className = '') {// ======================================================// üß©  UI COMPONENTS// ======================================================}    }        );            { originalError: error }            ERROR_CODES.NETWORK_ERROR,            error.message || 'Payment finalization failed',        throw new PaymentError(    } catch (error) {        return await response.json();        }            );                { status: response.status, ...errorData }                ERROR_CODES.NETWORK_ERROR,                errorData.message || 'Payment finalization failed',            throw new PaymentError(            const errorData = await response.json().catch(() => ({}));        if (!response.ok) {        });            })                network: network.toLowerCase()                transaction_hash: txHash,            body: JSON.stringify({            headers: { 'Content-Type': 'application/json' },            method: 'POST',        const response = await fetch('/api/onedream/finalize-payment', {    try {async function finalizePayment(txHash, network) {}    }        );            { originalError: error }            ERROR_CODES.TRANSACTION_ERROR,            error.message || 'TRON transfer failed',        throw new PaymentError(    } catch (error) {        };            explorerUrl: `${CONFIG.TRON.EXPLORER}${tx.transaction.txID}`            network: 'TRON',            txHash: tx.transaction.txID,        return {        }            throw new PaymentError('TRON transaction failed', ERROR_CODES.TRANSACTION_ERROR);        if (!tx || !tx.transaction || !tx.transaction.txID) {        const tx = await contract.transfer(recipient, amountSun).send();                const amountSun = Math.floor(amount * Math.pow(10, TRON_USDT_DECIMALS));        const TRON_USDT_DECIMALS = 6;                const contract = await window.tronWeb.contract().at(CONFIG.TRON.USDT_ADDRESS);        }            throw new PaymentError('TronWeb not available', ERROR_CODES.PROVIDER_ERROR);        if (!window.tronWeb || !window.tronWeb.ready) {    try {async function executeTronTransfer(recipient, amount) {}    }        );            { originalError: error }            ERROR_CODES.TRANSACTION_ERROR,            error.message || 'BSC transfer failed',        throw new PaymentError(                }            throw new PaymentError('Transaction rejected by user', ERROR_CODES.WALLET_ERROR);        if (error.code === 4001 || error.code === 'ACTION_REJECTED') {                console.error('[BSC Transfer] Error:', error);    } catch (error) {        };            explorerUrl: `${CONFIG.BSC.EXPLORER}${txHash}`            network: 'BSC',            txHash: txHash,        return {                console.debug('[BSC Transfer] TX Hash:', txHash);                });            }]                data: data                to: CONFIG.BSC.USDT_ADDRESS,                from: from,            params: [{            method: 'eth_sendTransaction',        const txHash = await eip1193Provider.request({                console.debug('[BSC Transfer] Sending transaction...');                const data = iface.encodeFunctionData("transfer", [recipient, amountWei]);        ]);            "function transfer(address to, uint256 amount) returns (bool)"        const iface = new ethers.utils.Interface([                const amountWei = ethers.utils.parseUnits(amount.toString(), BSC_USDT_DECIMALS);        const BSC_USDT_DECIMALS = 18;                }            throw new PaymentError('Ethers.js not loaded', ERROR_CODES.DEPENDENCY_ERROR);        if (typeof ethers === 'undefined') {                console.debug('[BSC Transfer] From:', from);                }            throw new PaymentError('No wallet account connected', ERROR_CODES.WALLET_ERROR);        if (!from) {                const from = accounts[0];        const accounts = await eip1193Provider.request({ method: 'eth_accounts' });                console.debug('[BSC Transfer] Starting unified transfer');    try {async function executeBSCTransferUnified(eip1193Provider, recipient, amount) {}    }        );            { originalError: error }            ERROR_CODES.NETWORK_ERROR,            error.message || 'Payment initialization failed',        throw new PaymentError(    } catch (error) {        return await response.json();        }            );                { status: response.status, ...errorData }                ERROR_CODES.NETWORK_ERROR,                errorData.message || 'Backend initialization failed',            throw new PaymentError(            const errorData = await response.json().catch(() => ({}));        if (!response.ok) {        });            })                network: network.toLowerCase()                vote_count: voteCount,                participant_id: participantId,            body: JSON.stringify({            headers: { 'Content-Type': 'application/json' },            method: 'POST',        const response = await fetch('/api/onedream/init-crypto-payment', {                trackEvent('payment_initiated', { participantId, voteCount, network });    try {async function initializeCryptoPayment(participantId, voteCount, network) {// ======================================================// üè¶  PAYMENT PROCESSING// ======================================================}    }        console.warn('[Network] Switch failed:', error.message);    } catch (error) {        }            }                }                    throw switchError;                } else {                    });                        }]                            blockExplorerUrls: ['https://bscscan.com/']                            rpcUrls: [CONFIG.BSC.RPC_URL],                            nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },                            chainName: 'Binance Smart Chain',                            chainId: targetChainId,                        params: [{                        method: 'wallet_addEthereumChain',                    await eip1193Provider.request({                if (switchError.code === 4902) {            } catch (switchError) {                });                    params: [{ chainId: targetChainId }]                    method: 'wallet_switchEthereumChain',                await eip1193Provider.request({            try {        if (chainId !== targetChainId) {                const targetChainId = `0x${CONFIG.BSC.CHAIN_ID.toString(16)}`;        const chainId = await eip1193Provider.request({ method: 'eth_chainId' });    try {        }        return;        console.debug('[Network] Skipping network switch on mobile');    if (isMobileDevice()) {async function ensureBSCNetworkDesktop(eip1193Provider) {}    }        );            { originalError: error }            ERROR_CODES.WALLET_ERROR,            error.message || 'Failed to connect via WalletConnect',        throw new PaymentError(        console.error('[WalletConnect] Error:', error);    } catch (error) {        return provider;        console.debug('[WalletConnect] Connected:', accounts[0]);                }            throw new Error('No accounts returned from WalletConnect');        if (!accounts || accounts.length === 0) {        const accounts = await provider.request({ method: 'eth_accounts' });                }            }                );                    { currentChain: chainId, requiredChain: '0x38' }                    ERROR_CODES.NETWORK_ERROR,                    'Please switch to BSC network in your wallet',                throw new PaymentError(            } catch (switchError) {                });                    params: [{ chainId: `0x${CONFIG.BSC.CHAIN_ID.toString(16)}` }]                    method: 'wallet_switchEthereumChain',                await provider.request({            try {            // Try to switch chain            console.warn('[WalletConnect] Wrong chain detected:', chainId);        if (chainId !== `0x${CONFIG.BSC.CHAIN_ID.toString(16)}`) {        const chainId = await provider.request({ method: 'eth_chainId' });        // ‚úÖ FIX #6: Verify chain after connection                await provider.connect();        console.debug('[WalletConnect] Connecting...');                });            }                ].filter(Boolean)                    `${window.location.origin}/favicon.ico`                    `${window.location.origin}/images/logo.png`,                icons: [                url: window.location.origin,                description: "Secure USDT Payment",                name: "OneDream Voting",            metadata: {            },                enableExplorer: true                 themeMode: 'dark',            qrModalOptions: {             showQrModal: true,            chains: [CONFIG.BSC.CHAIN_ID],            projectId: CONFIG.WALLETCONNECT.PROJECT_ID,        const provider = await EthereumProvider.init({        console.debug('[WalletConnect] Initializing provider...');                const EthereumProvider = await loadWalletConnect();        console.debug('[WalletConnect] Loading SDK...');    try {async function connectWalletMobile() {}    return new ethers.providers.Web3Provider(eip1193Provider);    }        throw new PaymentError('Ethers.js not loaded', ERROR_CODES.DEPENDENCY_ERROR);    if (typeof ethers === 'undefined') {function createEthersProvider(eip1193Provider) {}    throw new PaymentError('No valid provider found', ERROR_CODES.PROVIDER_ERROR);    }        return window.ethereum;    if (window.ethereum) {    }        return provider.provider;    if (provider && provider.provider && typeof provider.provider.request === 'function') {    }        return provider;    if (provider && typeof provider.request === 'function') {function normalizeProvider(provider) {}    }        throw error;        console.error('WalletConnect loading error:', error);    } catch (error) {        });            document.head.appendChild(script);            };                reject(new PaymentError('Failed to load WalletConnect', ERROR_CODES.PROVIDER_ERROR));            script.onerror = () => {            };                resolve(window.EthereumProvider);                console.log('‚úÖ WalletConnect SDK loaded');                }                    return;                    reject(new PaymentError('WalletConnect not properly loaded', ERROR_CODES.PROVIDER_ERROR));                if (!window.EthereumProvider) {            script.onload = () => {            script.src = CONFIG.WALLETCONNECT.SRC;            const script = document.createElement('script');        return new Promise((resolve, reject) => {                if (window.EthereumProvider) return window.EthereumProvider;    try {async function loadWalletConnect() {}    return null;    }        console.warn('Network detection error:', error);    } catch (error) {        }            }                console.debug('BSC detection error:', e);            } catch (e) {                if (chainId === '0x38') return 'BSC';                const chainId = await window.ethereum.request({ method: 'eth_chainId' });            try {        if (window.ethereum) {                }            }                console.debug('TRON detection error:', e);            } catch (e) {                if (tronNetwork && tronNetwork.net) return 'TRON';                const tronNetwork = await window.tronWeb.trx.getNodeInfo();            try {        if (window.tronWeb && window.tronWeb.ready) {    try {async function detectPreferredNetwork() {// ======================================================// üåê  NETWORK & WALLET MANAGEMENT// ======================================================}    element.appendChild(img);    element.innerHTML = '';    img.src = urls[0];        };        }            img.src = urls[attempts];            console.warn(`[QR] Fallback ${attempts}: trying next source`);        if (attempts < urls.length) {        attempts++;    img.onerror = () => {        const urls = [primaryUrl, secondaryUrl, canvasUrl];    let attempts = 0;        const canvasUrl = generateQRCanvas(text);    const secondaryUrl = `https://quickchart.io/qr?text=${encodeURIComponent(text)}&size=200`;    const primaryUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&margin=10&data=${encodeURIComponent(text)}`;        img.style.height = '200px';    img.style.width = '200px';    img.alt = 'QR Code';    img.className = 'mx-auto rounded-lg';    const img = document.createElement('img');        if (!element) return;    const element = document.getElementById(elementId);function generateQR(text, elementId) {}    return canvas.toDataURL();    ctx.fillText('Copy address below', size/2, size/2 + 10);    ctx.fillText('QR Loading...', size/2, size/2 - 10);    ctx.textAlign = 'center';    ctx.font = '12px sans-serif';    ctx.fillStyle = '#6b7280';    ctx.fillRect(0, 0, size, size);    ctx.fillStyle = '#f3f4f6';    const ctx = canvas.getContext('2d');    canvas.height = size;    canvas.width = size;    const canvas = document.createElement('canvas');function generateQRCanvas(text, size = 200) {}    return deepLinks[walletType] || deepLinks.metamask;    };        tokenpocket: `tpoutside://open?params=${currentUrl}`,        trustwallet: `https://link.trustwallet.com/open_url?coin_id=60&url=${currentUrl}`,        metamask: `https://metamask.app.link/dapp/${window.location.host}${window.location.pathname}`,    const deepLinks = {    const currentUrl = encodeURIComponent(window.location.href);function openWalletApp(walletType = 'metamask') {}    }        return false;        console.warn('[Wallet] Connection request failed:', error.message);    } catch (error) {        return accounts && accounts.length > 0;        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });    try {    if (!window.ethereum) return false;async function requestWalletConnection() {}    });        }, 100);            }                resolve(false);                clearInterval(checkInterval);            } else if (Date.now() - startTime > timeout) {                resolve(true);                clearInterval(checkInterval);            if (window.ethereum) {        const checkInterval = setInterval(() => {        const startTime = Date.now();        }            return;            resolve(true);        if (window.ethereum) {    return new Promise((resolve) => {async function waitForWalletProvider(timeout = 3000) {}    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);function isMobileDevice() {}    }        console.error('Tracking error:', e);    } catch (e) {        console.log(`[Analytics] ${name}`, metadata);        }            window.analytics.track(name, metadata);        if (window.analytics) {    try {function trackEvent(name, metadata = {}) {}    setAttempts(participantId, attempts);    attempts.push(now);        }        );            { attempts: attempts.length }            ERROR_CODES.RATE_LIMIT,            'Too many payment attempts. Please try again later.',        throw new PaymentError(    if (attempts.length >= CONFIG.LIMITS.MAX_RETRIES) {        );        t => now - t < CONFIG.LIMITS.ATTEMPT_TIMEOUT    const attempts = getAttempts(participantId).filter(    const now = Date.now();function checkRateLimit(participantId) {}    }        console.warn('[RateLimit] Failed to persist attempts:', e);    } catch (e) {        sessionStorage.setItem(`crypto_pay_attempts_${participantId}`, JSON.stringify(attempts));    try {function setAttempts(participantId, attempts) {}    }        return [];    } catch {        return JSON.parse(sessionStorage.getItem(`crypto_pay_attempts_${participantId}`) || '[]');    try {function getAttempts(participantId) {}    }        throw new PaymentError('Invalid vote count', ERROR_CODES.INVALID_INPUT);    if (!voteCount || isNaN(voteCount) || voteCount <= 0) {    }        throw new PaymentError('Invalid participant ID', ERROR_CODES.INVALID_INPUT);    if (!participantId || typeof participantId !== 'string') {function validateInputs(participantId, voteCount) {// ======================================================// üîå  UTILITY FUNCTIONS// ======================================================}    }        }            Error.captureStackTrace(this, PaymentError);        if (Error.captureStackTrace) {        this.metadata = metadata;        this.code = code;        this.name = 'PaymentError';        super(message);    constructor(message, code, metadata = {}) {class PaymentError extends Error {// ======================================================// üõ°Ô∏è  ERROR HANDLING CLASS// ======================================================// const paymentAttempts = new Map(); // REMOVED// Track payment attempts};    UNKNOWN_ERROR: 'UNKNOWN_ERROR'    DEPENDENCY_ERROR: 'DEPENDENCY_ERROR',    INITIALIZATION_ERROR: 'INITIALIZATION_ERROR',    PROVIDER_ERROR: 'PROVIDER_ERROR',    TIMEOUT: 'TIMEOUT',    TRANSACTION_ERROR: 'TRANSACTION_ERROR',    WALLET_ERROR: 'WALLET_ERROR',    NETWORK_ERROR: 'NETWORK_ERROR',    RATE_LIMIT: 'RATE_LIMIT',    INVALID_INPUT: 'INVALID_INPUT',const ERROR_CODES = {};    }        ATTEMPT_TIMEOUT: 5 * 60 * 1000        TIMEOUT_MS: 300000,        MAX_RETRIES: 3,    LIMITS: {    },        PROJECT_ID: scriptTag?.dataset?.wcProjectId || "61d9b98f81731dffa9988c0422676fc5"        SRC: "https://unpkg.com/@walletconnect/ethereum-provider@2.10.1/dist/index.umd.js",    WALLETCONNECT: {    },        WALLET_ADDRESS: scriptTag?.dataset?.tronWallet || "TVuPgEs4hSLSwPf8NMirVxeYse1vrmEtXL"        EXPLORER: "https://tronscan.org/#/transaction/",        USDT_ADDRESS: "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t",    TRON: {    },        WALLET_ADDRESS: scriptTag?.dataset?.bscWallet || "0xa3A25699995266af5Aa08dbeF2715f4b3698cF8d"        EXPLORER: "https://bscscan.com/tx/",        CHAIN_ID: 56,        RPC_URL: "https://bsc-dataseed.binance.org/",        USDT_ADDRESS: "0x55d398326f99059fF775485246999027B3197955",    BSC: {const CONFIG = {const scriptTag = document.currentScript || document.querySelector('script[src*="crypto-payments"]');// ‚úÖ Config uses data attributes or hardcoded values}    };        return false;        alert('Card payments are being set up. Please use crypto payment or QR code for now.');        console.warn('[Paystack] initiatePaystackPayment not defined - showing fallback');    window.initiatePaystackPayment = function() {if (typeof window.initiatePaystackPayment !== 'function') {// ‚úÖ Ensure Paystack fallback exists})();    document.head.appendChild(style);    `;        }            to { opacity: 1; transform: scale(1); }            from { opacity: 0; transform: scale(0.95); }        @keyframes crypto-fade-in {                }            animation: crypto-fade-in 0.2s ease-out;        .crypto-modal-fade-in {                }            to { transform: rotate(360deg); }        @keyframes crypto-spin {                }            animation: crypto-spin 0.8s linear infinite;            border-radius: 50%;            border-top-color: #3b82f6;            border: 3px solid #e5e7eb;            height: 32px;            width: 32px;        .loading-spinner {    style.textContent = `    style.id = 'crypto-payments-styles';    const style = document.createElement('style');        if (document.getElementById('crypto-payments-styles')) return;(function injectStyles() {// ‚úÖ Inject required CSS for loading spinner}    throw new Error('This script is designed to run in a browser environment');if (typeof window === 'undefined') {// Check if we're in a browser environment// ======================================================// üèóÔ∏è  INITIALIZATION & CONFIGURATION@push('scripts')
<!-- 1. Load ethers.js first (dependency for crypto-payments) -->
<script src="https://cdn.ethers.io/lib/ethers-5.7.umd.min.js"></script>

<!-- 2. Load crypto-payments.js BEFORE vote.js -->
<script src="{{ asset('js/crypto-payments.js') }}"></script>

<!-- 3. Load vote.js last -->
<script src="{{ asset('js/vote.js') }}"></script>
@endpush